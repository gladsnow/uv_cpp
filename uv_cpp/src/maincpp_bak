#include "uv.h"

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
	uv_tcp_t handle;
	uv_shutdown_t shutdown_req;
} conn_rec;

static uv_write_t write_req;


#define container_of(ptr, type, member) \
	((type *) ((char *) (ptr) - offsetof(type, member)))

#define ASSERT(expr)                                      \
	do {                                                     \
	if (!(expr)) {                                          \
	fprintf(stderr,                                       \
	"Assertion failed in %s on line %d: %s\n",    \
	__FILE__,                                     \
	__LINE__,                                     \
#expr);                                       \
	abort();                                              \
	}                                                       \
	} while (0)



static void connection_cb(uv_stream_t* stream, int status);
static void alloc_cb(uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf);
static void read_cb(uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf);
static void shutdown_cb(uv_shutdown_t* req, int status);
static void close_cb(uv_handle_t* handle);
static uv_write_t server_write_req;

static void server_write_cb(uv_write_t* req, int status)
{
	printf("server----write callback\n");

}

void on_read(uv_work_t* work_req)
{
	printf("on  read\n");
	uv_read_start((uv_stream_t*)work_req->data, alloc_cb, read_cb);
}

void on_after_read(uv_work_t* work_req,int status)
{
	printf("on after read\n");
	free(work_req);
}

static void connection_cb(uv_stream_t* stream, int status) {
	conn_rec* conn;
	int r;
	printf("server1---A connection is coming.\n");
	ASSERT(status == 0);

	conn = (conn_rec*)malloc(sizeof *conn);
	ASSERT(conn != NULL);

	r = uv_tcp_init(stream->loop, &conn->handle);
	ASSERT(r == 0);

	r = uv_accept(stream, (uv_stream_t*)&conn->handle);
	ASSERT(r == 0);
	//uv_shutdown(&conn->shutdown_req, stream, shutdown_cb);
	//Sleep(1000);
	//char hello[]="hello client\n";
	//uv_buf_t buf;
	//buf = uv_buf_init(hello,(unsigned int)strlen(hello));
	//uv_write(&server_write_req,stream, &buf, strlen(hello), server_write_cb);
	uv_read_start((uv_stream_t*)&conn->handle, alloc_cb, read_cb);

	uv_work_t* work_req = (uv_work_t*)malloc(sizeof(*work_req));
	work_req->data = stream;

	 uv_queue_work(stream->loop, work_req, on_read, on_after_read);
	ASSERT(r == 0);
}


static void alloc_cb(uv_handle_t* handle,
					 size_t suggested_size,
					 uv_buf_t* buf) {
						 static char slab[65536];
						 buf->base = slab;
						 buf->len = sizeof(slab);
}


static void read_cb(uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {
	conn_rec* conn;
	int r;

	if (nread >= 0)
	{
		printf("server received data:%s\n",buf->base);

		/*Sleep(1000);
		char hello[]="hello client again";
		uv_buf_t buf;
		buf = uv_buf_init(hello,(unsigned int)strlen(hello));

		uv_write(&write_req,stream, &buf, 1, server_write_cb);*/
		return;
	}

	ASSERT(nread == UV_EOF);

	conn = container_of(stream, conn_rec, handle);

	r = uv_shutdown(&conn->shutdown_req, stream, shutdown_cb);
	ASSERT(r == 0);
}


static void connection_cb2(uv_stream_t* stream, int status) {
	conn_rec* conn;
	int r;
	printf("server2---A connection is coming.\n");
	ASSERT(status == 0);

	conn = (conn_rec*)malloc(sizeof *conn);
	ASSERT(conn != NULL);

	r = uv_tcp_init(stream->loop, &conn->handle);
	ASSERT(r == 0);

	r = uv_accept(stream, (uv_stream_t*)&conn->handle);
	ASSERT(r == 0);

	//Sleep(1000);
	//char hello[]="hello client\n";
	//uv_buf_t buf;
	//buf = uv_buf_init(hello,(unsigned int)strlen(hello));
	//uv_write(&server_write_req,stream, &buf, strlen(hello), server_write_cb);
//	uv_shutdown(&conn->shutdown_req, stream, shutdown_cb);
	uv_read_start((uv_stream_t*)&conn->handle, alloc_cb, read_cb);
	ASSERT(r == 0);
}

static void shutdown_cb(uv_shutdown_t* req, int status) {
	conn_rec* conn = container_of(req, conn_rec, shutdown_req);
	printf("server---shutdown socket\n");
	uv_close((uv_handle_t*)&conn->handle, close_cb);
}


static void close_cb(uv_handle_t* handle) {
	conn_rec* conn = container_of(handle, conn_rec, handle);
	printf("server----close callback\n");
	free(conn);
}

static void server(void)
{
	struct sockaddr_in addr;
	uv_loop_t* loop;
	int r;
	uv_tcp_t tcp_server;
	

	ASSERT(0 == uv_ip4_addr("127.0.0.1", 8900, &addr));
	loop = uv_default_loop();
	r = uv_tcp_init(loop, &tcp_server);
	ASSERT(r == 0);

	r = uv_tcp_bind(&tcp_server, (const struct sockaddr*) &addr, 0);
	ASSERT(r == 0);

	r = uv_listen((uv_stream_t*)&tcp_server, 128, connection_cb);
	ASSERT(r == 0);

	r = uv_run(loop, UV_RUN_DEFAULT);
	ASSERT(0 && "Blackhole server dropped out of event loop.");
}


static int connect_cb_called;
static int write_cb_called;
static int close_cb_called;


static void client_alloc_cb(uv_handle_t* handle,
					 size_t suggested_size,
					 uv_buf_t* buf) {
						 static char slab[1024];
						 buf->base = slab;
						 buf->len = sizeof(slab);
}


static void client_close_cb(uv_handle_t* handle) {
	printf("client---close callback\n");
	close_cb_called++;
}

static void write_cb(uv_write_t* req, int status) {
	//ASSERT(status < 0);
	printf("client---write callback\n");
	write_cb_called++;
}

static void client_read_cb(uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {
	int r;

	if (nread >= 0)
	{
		printf("client received data:%s\n",buf->base);
		Sleep(1000);
		char hello[]="hello server again\n";
		uv_buf_t buf;
		buf = uv_buf_init(hello,(unsigned int)strlen(hello));
		uv_write(&write_req,stream, &buf, 1, write_cb);
		return;
	}

	ASSERT(nread == UV_EOF);

	uv_close((uv_handle_t*)stream, client_close_cb);
}




static void connect_cb(uv_connect_t* req, int status) {
//	ASSERT(status < 0);
	printf("client---connect ok\n");
	connect_cb_called++;

	//Sleep(1000);

	//char hello[]="hello server\n";
	//uv_buf_t buf;
	//buf = uv_buf_init(hello,(unsigned int)strlen(hello));
	//uv_write(&write_req,req->handle, &buf, 1, write_cb);

	//uv_read_start(req->handle, client_alloc_cb, client_read_cb);
}


static void client(void)
{
	uv_connect_t connect_req[50];
	struct sockaddr_in addr;
	
	uv_tcp_t conn;
	
	uv_loop_t* loop;

	int r;
	loop = uv_default_loop();
	uv_tcp_init(loop,&conn);
	ASSERT(0 == uv_ip4_addr("127.0.0.1",8900 , &addr));

	for(int i = 0;i <50;i++)
	{
		Sleep(1000);
		uv_tcp_connect(&connect_req[i],&conn,(const struct sockaddr*) &addr,connect_cb);
	}

	uv_run(loop,UV_RUN_DEFAULT);
}

void test()
{
	struct sockaddr_in addr;
	uv_loop_t* loop;
	int r;
	uv_connect_t connect_req;
	uv_tcp_t tcp_server;
	uv_tcp_t client;

	loop = uv_default_loop();
	ASSERT(0 == uv_ip4_addr("127.0.0.1", 8900, &addr));

	r = uv_tcp_init(loop, &tcp_server);
	uv_tcp_init(loop,&client);

	ASSERT(r == 0);

	r = uv_tcp_bind(&tcp_server, (const struct sockaddr*) &addr, 0);
	ASSERT(r == 0);

	r = uv_listen((uv_stream_t*)&tcp_server, 128, connection_cb);
	ASSERT(r == 0);

	r = uv_tcp_connect(&connect_req,&client,(const struct sockaddr*) &addr,connect_cb);
	r = uv_run(loop, UV_RUN_DEFAULT);
}

int main(void)
{
	printf("*************SERVER************\n");
	server();
	//Sleep(3000);
	//uv_thread_t thread_array[2];

	//uv_thread_create(&thread_array[1],(uv_thread_cb*)&server,NULL);
	//printf("*****************Client***********\n");
	//client();
	//getchar();
	return 0;
}